# 第三章：装饰者模式

## 定义

## 动态地将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的替代方案。

当需要动态地扩展某（已有）组件的功能时，可使用装饰者模式：

令装饰者和被装饰对象有相同的超类型，在装饰者中维护一个类型为该超类型指针的变量。则装饰者可以在所委托被装饰者的行为之前/或之后，加上自己的行为，以达到特定的目的。

```cpp
Beverage *beverage;

double Milk::cost()
{
	return this->beverage->cost() + 0.1;
}
```

## 装饰者模式的必要性和可行性

当需要扩展某组件的功能时，若采用一般的硬编码方法，会面临“类爆炸”，且每次扩展组件的功能都需要修改代码，无法做到“对修改关闭”。

1. 由于对不同的组件需要扩展出许多不同的功能，采用硬编码一一枚举，众多的组合方式要求使用大量相似而又各不相同的类，这会造成“类爆炸”。
2. 由于无法将变化的部分与不变的部分分割开来，当需要扩展某组件的功能时，或当需要改变功能的组合方式时，需要修改已有的代码，无法做到“对修改关闭”。

若使用策略模式，可以避免上述这两个问题：

1. 为每个组件和每个功能各设计一个类，则不同的“组件 + 功能”的组合可用其对应的类的组合实现，而无需为每种组合设计一个类，这样可以大幅减少需要的类的数量。
2. 组件和功能的内部实现是不变的部分，组件和功能的组合方式是变化的部分。通过将变化的部分与不变的部分分割开来，可以做到组件功能的动态扩展，而无需修改已有的代码，做到了“对扩展开放，对修改关闭”。

## 设计理念

1. 从众多观察者中抽象出 `update()` 接口，主题维护一个观察者集合，在需要通知观察者时，依次调用集合中各个观察者的 `update()` 方法。
2. 主题通过维护观察者集合实现观察者的动态插拔。

## 设计原则

1. 类应该对扩展开放，对修改关闭。

## UML 图

装饰者模式的“理论”类图：p91

![“理论”类图](UML1.jpg)

装饰者模式的“实际”类图：p92

![“实际”类图](UML2.jpg)

## 代码解释

1. 这里Beverage的getDescription需要设计成虚函数。我自己写的时候就掉到这个坑里去了。如果不是虚函数，虽然配料类中将getDescription声明成纯虚函数，但如果是通过Beverage的指针指向配料实例的话，调用getDescription将会调用Beverage里的函数。也就是子类将父类的方法重新声明为虚函数并不能用来实现多态。
