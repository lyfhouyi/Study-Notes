# 第五章：单件模式

## 定义

确保一个类只有一个实例，并提供全局访问点。

## 使用场景

当你需要确保程序中的某个类只有一个实例时，可以使用单件模式。单件模式通常用来管理共享的资源，将类对象的唯一实例作为共享资源的（全局）控制器。使用单件模式，可以确保程序中使用的全局资源只有一份。

## 单件模式的必要性和可行性

有些类对象只需要一个实例，且只能有一个实例。如果制造出多个实例，就会导致许多问题产生。仅凭全局变量，很难做到有且只有一个实例，且”急切实例化“会导致资源浪费：

1. 全局变量可以提供全局访问，但不能确保只有一个实例。
2. 全局变量必须在程序一开始就进行初始化，若该对象非常耗费资源，而程序在执行过程中一直没有使用它，则会带来不必要的浪费，且影响程序启动速度。

单件模式可以和全局变量一样方便，而没有全局变量的缺点：

1. 单件模式可以确保只有一个实例会被创建，且可以和使用全局变量一样方便。因为使用单件模式创建出的实例全局可见且贯穿应用程序的整个生命周期。
2. 适当的单件模式实现采用了”延迟实例化“技术，只有在程序第一次需要这个实例的时候才会实例化，避免了资源浪费；且程序一开始不用实例化该类对象，可以提高程序的启动速度。

## 设计理念

1. 私有化类的构造函数，禁止拷贝构造函数、赋值运算符。
2. 使用类静态成员函数向外界提供实例化接口；将该接口实现为调用私有的构造函数。
3. 可以使用类静态成员变量维护唯一的实例化对象，也可以不用，这取决于具体实现。
4. 适当的实现具有”延迟实例化“的功能。

## 设计原则



## UML 图

p177

![类图](UML.jpg)

## 代码解释

1. UML 类图是标准的单件模式类图。本案例的实现方式不需要维护一个类静态成员变量以保存实例化对象，因为在 c++ 11 中使用静态局部变量既可以保证线程安全，又可以实现”延迟实例化“：

   * 利用 c++11 的 Magic Statics 特性，在 `getInstance()` 方法中使用了静态局部变量，目的是保证线程安全 （C++11, GCC > 4.3, VS2015支持该特性）。

     > c++ 11 Magic Statics ：
     >
     > If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.
     > 如果当变量在初始化的时候，并发线程同时进入声明语句，并发线程将会阻塞并等待初始化结束。

   * 使用静态局部变量可以实现”延迟实例化“，因为函数内静态变量的生命周期为：从程序运行至第一次遇到声明开始，直到程序结束时结束。

2. 必须禁止拷贝构造，否则如下调用会产生两个对象（初始化一次，拷贝构造一次）：

   ```cpp
   ChocolateBoiler d = ChocolateBoiler::getInstance();
   ```

   若将拷贝构造禁止，则上面的代码无法通过编译。

3. 注意在使用的时候需要声明单例的引用 `ChocolateBoiler&` 才能获取对象：

   ```cpp
   ChocolateBoiler& chocolateBoiler1 = ChocolateBoiler::getInstance();
   ```

4. 为什么 `static ChocolateBoiler& getInstance();` 方法返回引用而不是指针：

   指针和引用在语法上的最大区别就是指针可以为NULL，并可以通过delete运算符删除指针所指的实例，而引用则不可以。

   由该语法区别引申出的语义区别之一就是这些实例的生存期意义：通过引用所返回的实例，生存期由非用户代码管理；而通过指针返回的实例，其可能在某个时间点没有被创建，或是可以被删除的，这不符合单件模式的规范。

5. 全局变量和单件模式的区别：

   单件模式拥有全局变量的众多特点：全局可见且贯穿应用程序的整个生命周期。除此之外，单件模式还拥有一些全局变量所不具有的性质：同一类型的对象实例只能有一个，同时适当的实现还拥有延迟初始化（Lazy）的功能，可以避免耗时的全局变量初始化所导致的启动速度不佳等问题。

   要说明的是，Singleton 的最主要目的并不是作为一个全局变量使用，而是保证类型实例有且仅有一个。它所具有的全局访问特性仅仅是它的一个副作用。但正是这个副作用使它更类似于包装好的全局变量，从而允许各部分代码对其直接进行操作。
